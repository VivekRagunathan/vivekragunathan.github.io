---
title: .NET Reflection Extravanganza !!!
author: vivekragunathan
layout: post
date: 2006-05-11T22:40:00+00:00
url: /2006/05/11/net-reflection-extravanganza/
blogger_blog:
  - developerexperience.blogspot.com
blogger_author:
  - Vivek Ragunathan
blogger_efd3de0af000aedcb3351cb4b4995ef6_permalink:
  - 114738729760663659
categories:
  - CodeProject
  - Uncategorized

---
I was involved in this module for the past few weeks and successfully completed it in a very innovative way. Ok, this was the problem. We have a COM server, let us name it Server. I had to write an assembly in C#, let us call it Bridge, that will listen to all of the events fired by the Server and perform an action Action. To keep that Action simple, let us assume we have to log them in the database. But the Server fires hundreds of events, and it is not wise to write up static event handlers for all of them. Also if more events are added in the future, it is possible to support the Bridge.

So I came up with a different approach with the incredible Reflection in .NET. All of the events fired by the Server, its prototype and other relevant information can be got through reflection, and for each of the event methods, an event sink [event handler] can be generated at runtime. This means I have to create a method at runtime matching the prototype of the event. The dynamic method thus generated runtime has to appended with some method body so as to do the Action, and then has to be registered as the event sink for the corresponding event. So when the event is fired by the Server, the dynamically created event handler is called without any intervention. This is the theme of my solution. This keeps the Bridge unaffected for any event related changes in the Server.

But achieving this solution and make it work, it was a great and exciting adventure.

1. I was able to get the event information about the events fired by Server through reflection. I used the following sort of code for generating the dynamic method or the supposedly the dynamic event handler:-

<pre><font face="Courier New" size="3" color="#006600"><br />using System;<br />using System.Threading;<br />using System.Reflection;<br />using System.Reflection.Emit;<br /><br />class TaskDynamicEventHandler<br />{<br />    public static void CreateDynamicEventHandler(ref TypeBuilder myTypeBld,<br />                         string methodName,<br />                         Type[] eventMethodParameters,<br />                         Type eventreturnType)<br />    {<br />        MethodBuilder myMthdBld = myTypeBld.DefineMethod(methodName,<br />                          MethodAttributes.Public | MethodAttributes.Static,<br />                          eventreturnType,<br />                          eventMethodParameters);<br /><br />        ILGenerator ILout = myMthdBld.GetILGenerator();<br /><br />        int numParams = eventMethodParameters.Length;<br /><br />        for (byte x = 0; x &lt; numParams; x++)<br />        {<br />            // Load the parameter onto the evaulation stack<br />            ILout.Emit(OpCodes.Ldarg_S, x);<br />        }<br /><br />        // Use the above sort of logic to access the event parameter<br />        // values and then package into a hashtable, and then call<br />        // a static method HandleEvent in TaskDynamicEventHandler,<br />        // which takes the hashtable as a parameter. All the code is <br />        // generated in IL using ILGenerator.<br /><br />        ILout.Emit(OpCodes.Ret);<br />    }<br /><br />    public static void Main()<br />    {<br />        AppDomain myDomain = Thread.GetDomain();<br />        AssemblyName asmName = new AssemblyName("DynamicAssembly1");<br />        AssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(asmName,<br />                       AssemblyBuilderAccess.RunAndSave);<br /><br />        ModuleBuilder myModule = myAsmBuilder.DefineDynamicModule("DynamicModule1",<br />                                      "MyDynamicAsm.dll");<br /><br />        TypeBuilder myTypeBld = myModule.DefineType("MyDynamicType",<br />                                       TypeAttributes.Public);<br /><br />        string dynamicMethodName = "DynamicEventHandler";<br />        CreateDynamicEventHandler(myTypeBld,<br />                         dynamicMethodName,<br />                         eventMethodParameters,<br />                         eventreturnType);        <br /><br />        Type myType = myTypeBld.CreateType();<br />        <br /><br />        myAsmBuilder.Save("MyDynamicAsm.dll");<br />    }<br />}<br /></font></pre>

The drawback in this approach was that a dynamic assembly+module+type was getting created for each event. This was not efficient enough, and so slightly altered the logic to create the dynamic assembly+module+type once and add the methods [dynamic event handlers] to the dynamic type.

Though a level of efficieny may have been achieved, it was not elegant enough to be satisfied. The dynamic event handlers [DEH] are all methods of a specific type belonging to a different assembly that is generated at run-time, and these DEH do not belong to the same assembly as the TaskDynamicEventHandler class. The responsibility of the DEHs was to read its parameter name and values at runtime, package them into a hashtable and call a method HandleEvent of TaskDynamicEventHandler, and it is in HandleEvent that the actual job of logging is done. Well, the actual job is not only logging but other things that require access to the memebers of TaskDynamicEventHandler. So the non-elegance here was that HandleEvent was exposed as public static method so that the DEH in the dynamic assembly could call, which lead to the ugliness where HandleEvent was exposed to the outside world from the assembly to which TaskDynamicEventHandler belongs to. So HandleEvent cannot be non-public. But it was required for other reasons to be an instance method.

2. Here is the most interesting part. The aim was then make the DEH call an instance method of the TaskDynamicEventHandler ie HandleEvent. How do you make a static method call an instance method ? Well, if I have an object reference of the TaskDynamicEventHandler class in the DEH execution, and IF i can load that on to the evaluation stack [using the IL code/ILGenerator], then i call an instance method. That was the pain and it was pretty tricky and interesting that everybody to whomever I explained could not correctly grasp that the &#8216;this&#8217; used during the compiled code will not be the same in the runtime IL code of the DEH, and neither can I load an object reference without me creating it or getting it as a parameter. That is all the .NET type security. You will not be given any chance to do reinterpret_cast kind of stuff at all. But you can pass the TaskDynamicEventHandler object reference [this] to the DEH but that beats the goal where the prototype of the DEH will not match the prototpye of its corresponding event and so cannot act as a sink.

3. Here comes .NET 2.0 for the rescue to a certain extent, and helps us acheive the aim &#8211; Efficiency and Elegance. There is a class by name DynamicMethod to dynamically create methods. The beauty of the DynamicMethod is that it is possible to add the dynamic method as member of the current class TaskDynamicEventHandler.

<pre><font face="Courier New" size="3" color="#006600"><br />// returnType - event method's return type<br />// parameterTypes - event method's parameter types list<br />ArrayList parameterTypes = new ArrayList(parameterTypes);<br />parameterTypes.Insert(0, this.GetType());<br /><br />DynamicMethod dynamicEventHandler = new DynamicMethod(methodName,<br />            returnType,<br />            (Type[])parameterTypes.ToArray(typeof(Type)),<br />            typeof(TaskDynamicEventHandler));<br /></font></pre>

Hence the DEH is now a part of the same assembly and class and it can call even non-public methods. Efficiency was well achieved but still elegant was a few feet away. The dynamic method created and added to TaskDynamicEventHandler using DynamicMethod class is a static method and hence cannot access instance methods of TaskDynamicEventHandler, although it can access non-public methods.

3. Here is the most interesting part. The aim of this iteration is to make the DEH call an instance method of the TaskDynamicEventHandler ie HandleEvent. How do you make a static method call an instance method ? Well, if I have an object reference of the TaskDynamicEventHandler class during the DEH execution, and if i can load that on to the evaluation stack [using the IL code/ILGenerator], then i call an instance method. Things are going to get interesting now. The difference between an instance and static method is that an instance method has the object reference, to which it belongs, as the first parameter while a static method does not. Though syntactically, the object reference is not added, the compiler adds it. So while creating the dynamic method [DEH] for an event, the TaskDynamicEventHandler object reference [this] is added as the first parameter to the event parameter list. This makes the DEH seem to be an instance method. So during runtime, when an event is fired, its corresponding DEH executes, the Lgarg_0 in the IL code represents the object reference it belongs to, and it is the same as that for HandleEvent.

4. But even now the HandleEvent is public and is vulnerable for improper usage. I made it a virtual method. That is fun, and now it is entirely the user&#8217;s responsibility to avoid improper usage, and it is upto the user to override HandleEvent to do whatever he wants.

5. Few minor things- Added Trace.WriteLine in the IL code using ILGenerator for debugging; Added try-catch exception blocks for catching exceptions, but unfortunately does not seem to work.

All of these approaches until the final efficient and elegant solution took several iterations of revisit and review. I will not able to explain about the difficulties and tough IL debugging experience that I went through trying to make the HandleEvent an instance virtual method, although I will be able to share the joy and knowledge now. It was a great experience !!!